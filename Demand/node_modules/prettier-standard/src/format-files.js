"use strict";require("regenerator-runtime/runtime");require("core-js/modules/es6.regexp.split");require("core-js/modules/es7.array.includes");require("core-js/modules/es6.promise");function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function step(key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _next(value) {step("next", value);}function _throw(err) {step("throw", err);}_next();});};}
var path = require('path');
var fs = require('fs');
var glob = require('glob');
var Rx = require('rxjs/Rx');
var format = require('prettier-eslint');
var chalk = require('chalk');
var getStdin = require('get-stdin');
var nodeIgnore = require('ignore');
var findUp = require('find-up');
var memoize = require('lodash.memoize');
var indentString = require('indent-string');
var getLogger = require('loglevel-colored-level-prefix');
var eslintConfig = require('@sheerun/eslint-config-standard');
var messages = require('./messages');

var LINE_SEPERATOR_REGEX = /(\r|\n|\r\n)/;
var rxGlob = Rx.Observable.bindNodeCallback(glob);
var rxReadFile = Rx.Observable.bindNodeCallback(fs.readFile);
var rxWriteFile = Rx.Observable.bindNodeCallback(fs.writeFile);
var findUpSyncMemoized = memoize(findUpSync, function resolver() {
  var args = Array.prototype.slice.call(arguments);
  return args.join('::');
});
var getIsIgnoredMemoized = memoize(getIsIgnored);

var logger = getLogger({ prefix: 'prettier-standard' });

function getPathInHostNodeModules(module) {
  var modulePath = findUp.sync(`node_modules/${module}`);

  if (modulePath) {
    return modulePath;
  }

  var result = findUp.sync(`node_modules/${module}`, { cwd: __dirname });

  return result;
}

function coercePath(input) {
  return path.isAbsolute(input) ? input : path.join(process.cwd(), input);
}

function formatFilesFromArgv(
fileGlobs)







{var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},_ref$logLevel = _ref.logLevel,logLevel = _ref$logLevel === void 0 ? logger.getLevel() : _ref$logLevel,_ref$eslintPath = _ref.eslintPath,eslintPath = _ref$eslintPath === void 0 ? getPathInHostNodeModules('eslint') : _ref$eslintPath,_ref$prettierPath = _ref.prettierPath,prettierPath = _ref$prettierPath === void 0 ? getPathInHostNodeModules('prettier') : _ref$prettierPath,_ref$ignore = _ref.ignore,ignoreGlobs = _ref$ignore === void 0 ? [] : _ref$ignore,_ref$eslintIgnore = _ref.eslintIgnore,applyEslintIgnore = _ref$eslintIgnore === void 0 ? true : _ref$eslintIgnore;
  logger.setLevel(logLevel);

  var eslint = require(eslintPath);
  var fixable = [];
  var rules = {};

  if (eslint && eslint.linter) {
    eslint.linter.getRules().forEach(function (v, k) {
      if (v.meta.fixable) {
        fixable.push(k);
      }
    });
  }

  Object.keys(eslintConfig.rules).forEach(function (k) {
    if (fixable.indexOf(k) !== -1) {
      rules[k] = eslintConfig.rules[k];
    }
  });
  rules['jsx-quotes'] = ['error', 'prefer-single'];

  var prettierESLintOptions = {
    logLevel,
    eslintPath,
    prettierPath,
    eslintConfig: {
      parser: getPathInHostNodeModules('babel-eslint'),
      parserOptions: eslintConfig.parserOptions,
      rules } };



  if (fileGlobs.length > 0) {
    return formatFilesFromGlobs(
    fileGlobs,
    ignoreGlobs.slice(),
    { write: true },
    prettierESLintOptions,
    applyEslintIgnore);

  }

  return formatStdin(prettierESLintOptions);
}function

formatStdin(_x) {return _formatStdin.apply(this, arguments);}function _formatStdin() {_formatStdin = _asyncToGenerator(regeneratorRuntime.mark(function _callee(prettierESLintOptions) {var stdinValue, formatted;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:_context.next = 2;return (
              getStdin());case 2:stdinValue = _context.sent.trim();_context.prev = 3;

            formatted = format(Object.assign({}, { text: stdinValue }, prettierESLintOptions));
            process.stdout.write(formatted);return _context.abrupt("return",
            Promise.resolve(formatted));case 9:_context.prev = 9;_context.t0 = _context["catch"](3);

            logger.error(
            'There was a problem trying to format the stdin text',
            `\n${indentString(_context.t0.stack, 4)}`);

            process.exitCode = 1;return _context.abrupt("return",
            Promise.resolve(stdinValue));case 14:case "end":return _context.stop();}}}, _callee, this, [[3, 9]]);}));return _formatStdin.apply(this, arguments);}



function formatFilesFromGlobs(
fileGlobs,
ignoreGlobs,
cliOptions,
prettierESLintOptions,
applyEslintIgnore)
{
  var concurrentGlobs = 3;
  var concurrentFormats = 10;
  return new Promise(function (resolve) {
    var successes = [];
    var failures = [];
    var unchanged = [];
    Rx.Observable.from(fileGlobs).
    mergeMap(
    getFilesFromGlob.bind(null, ignoreGlobs, applyEslintIgnore),
    null,
    concurrentGlobs).

    concatAll().
    distinct().
    mergeMap(filePathToFormatted, null, concurrentFormats).
    subscribe(onNext, onError, onComplete);

    function filePathToFormatted(filePath) {
      return formatFile(filePath, prettierESLintOptions, cliOptions);
    }

    function onNext(info) {
      if (info.error) {
        failures.push(info);
      } else if (info.unchanged) {
        unchanged.push(info);
      } else {
        successes.push(info);
      }
    }

    function onError(error) {
      logger.error(
      'There was an unhandled error while formatting the files',
      `\n${indentString(error.stack, 4)}`);

      process.exitCode = 1;
      resolve({ error, successes, failures });
    }

    function onComplete() {
      if (successes.length) {
        console.error(
        messages.success({
          success: chalk.green('success'),
          count: successes.length,
          countString: chalk.bold(successes.length) }));


      }
      if (failures.length) {
        process.exitCode = 1;
        console.error(
        messages.failure({
          failure: chalk.red('failure'),
          count: failures.length,
          countString: chalk.bold(failures.length) }));


      }
      if (unchanged.length) {
        console.error(
        messages.unchanged({
          unchanged: chalk.gray('unchanged'),
          count: unchanged.length,
          countString: chalk.bold(unchanged.length) }));


      }
      resolve({ successes, failures });
    }
  });
}

function getFilesFromGlob(ignoreGlobs, applyEslintIgnore, fileGlob) {
  var globOptions = { ignore: ignoreGlobs };
  if (!fileGlob.includes('node_modules')) {


    globOptions.ignore.push('**/node_modules/**');
  }
  return rxGlob(fileGlob, globOptions).map(function (filePaths) {
    return filePaths.filter(function (filePath) {
      return applyEslintIgnore ?
      !isFilePathMatchedByEslintignore(filePath) :
      true;
    });
  });
}

function formatFile(filePath, prettierESLintOptions, cliOptions) {
  var fileInfo = { filePath };
  var format$ = rxReadFile(filePath, 'utf8').map(function (text) {
    fileInfo.text = text;
    fileInfo.formatted = format(Object.assign({}, { text, filePath }, prettierESLintOptions));
    return fileInfo;
  });

  if (cliOptions.write) {
    format$ = format$.mergeMap(function (info) {
      if (info.text === info.formatted) {
        return Rx.Observable.of(Object.assign(fileInfo, { unchanged: true }));
      } else {
        return rxWriteFile(filePath, info.formatted).map(function () {return fileInfo;});
      }
    });
  } else {
    format$ = format$.map(function (info) {
      console.error(info.formatted);
      return info;
    });
  }

  return format$.catch(function (error) {
    logger.error(
    `There was an error formatting "${fileInfo.filePath}":`,
    `\n${indentString(error.stack, 4)}`);

    return Rx.Observable.of(Object.assign(fileInfo, { error }));
  });
}

function getNearestEslintignorePath(filePath) {var _path$parse =
  path.parse(filePath),dir = _path$parse.dir;
  return findUpSyncMemoized('.eslintignore', dir);
}

function isFilePathMatchedByEslintignore(filePath) {
  var eslintignorePath = getNearestEslintignorePath(filePath);
  if (!eslintignorePath) {
    return false;
  }

  var eslintignoreDir = path.parse(eslintignorePath).dir;
  var filePathRelativeToEslintignoreDir = path.relative(
  eslintignoreDir,
  filePath);

  var isIgnored = getIsIgnoredMemoized(eslintignorePath);
  return isIgnored(filePathRelativeToEslintignoreDir);
}

function findUpSync(filename, cwd) {
  return findUp.sync('.eslintignore', { cwd });
}

function getIsIgnored(filename) {
  var ignoreLines = fs.
  readFileSync(filename, 'utf8').
  split(LINE_SEPERATOR_REGEX).
  filter(function (line) {return Boolean(line.trim());});
  var instance = nodeIgnore();
  instance.add(ignoreLines);
  return instance.ignores.bind(instance);
}

module.exports = formatFilesFromArgv;