"use strict";require("core-js/modules/es6.promise");require("regenerator-runtime/runtime");function _asyncToGenerator(fn) {return function () {var self = this,args = arguments;return new Promise(function (resolve, reject) {var gen = fn.apply(self, args);function step(key, arg) {try {var info = gen[key](arg);var value = info.value;} catch (error) {reject(error);return;}if (info.done) {resolve(value);} else {Promise.resolve(value).then(_next, _throw);}}function _next(value) {step("next", value);}function _throw(err) {step("throw", err);}_next();});};}
var fsMock = require('fs');
var findUpMock = require('find-up');
var formatMock = require('prettier-eslint');
var globMock = require('glob');
var mockGetStdin = require('get-stdin');
var formatFiles = require('./format-files');

jest.mock('fs');

jest.mock(
'/node_modules/eslint',
function () {return {
    linter: {
      getRules() {
        return [];
      } } };},


{ virtual: true });


beforeEach(function () {
  process.stdout.write = jest.fn();
  console.error = jest.fn();
  formatMock.mockClear();
  fsMock.writeFile.mockClear();
  fsMock.readFile.mockClear();
});

test('sanity test', _asyncToGenerator(regeneratorRuntime.mark(function _callee() {var globs, successOutput;return regeneratorRuntime.wrap(function _callee$(_context) {while (1) {switch (_context.prev = _context.next) {case 0:
          globs = ['src/**/1*.js', 'src/**/2*.js'];_context.next = 3;return (
            formatFiles(globs));case 3:
          expect(globMock).toHaveBeenCalledTimes(globs.length);
          expect(fsMock.readFile).toHaveBeenCalledTimes(6);
          expect(formatMock).toHaveBeenCalledTimes(6);
          expect(fsMock.writeFile).toHaveBeenCalledTimes(6);
          expect(console.error).toHaveBeenCalledTimes(1);
          successOutput = expect.stringMatching(/success.*6.*files/);
          expect(console.error).toHaveBeenCalledWith(successOutput);case 10:case "end":return _context.stop();}}}, _callee, this);})));


test('glob call inclues an ignore of node_modules', _asyncToGenerator(regeneratorRuntime.mark(function _callee2() {var fileGlob, globOptions, callback;return regeneratorRuntime.wrap(function _callee2$(_context2) {while (1) {switch (_context2.prev = _context2.next) {case 0:
          fileGlob = 'src/**/1*.js';_context2.next = 3;return (
            formatFiles([fileGlob]));case 3:
          globOptions = expect.objectContaining({
            ignore: expect.arrayContaining(['**/node_modules/**']) });

          callback = expect.any(Function);
          expect(globMock).toHaveBeenCalledWith(fileGlob, globOptions, callback);case 6:case "end":return _context2.stop();}}}, _callee2, this);})));


test('glob call excludes an ignore of node_modules', _asyncToGenerator(regeneratorRuntime.mark(function _callee3() {var fileGlob;return regeneratorRuntime.wrap(function _callee3$(_context3) {while (1) {switch (_context3.prev = _context3.next) {case 0:
          fileGlob = 'foo/node_modules/stuff*.js';_context3.next = 3;return (
            formatFiles([fileGlob]));case 3:
          expect(globMock).not.toHaveBeenCalledWith(
          expect.any,
          expect.objectContaining({

            ignore: expect.arrayContaining(['**/node_modules/**']) }),

          expect.any);case 4:case "end":return _context3.stop();}}}, _callee3, this);})));



test('should accept stdin', _asyncToGenerator(regeneratorRuntime.mark(function _callee4() {var text;return regeneratorRuntime.wrap(function _callee4$(_context4) {while (1) {switch (_context4.prev = _context4.next) {case 0:
          mockGetStdin.stdin = '  var [ foo, {  bar } ] = window.APP ;';_context4.next = 3;return (
            formatFiles([], { stdin: true }));case 3:
          expect(formatMock).toHaveBeenCalledTimes(1);

          text = mockGetStdin.stdin.trim();
          expect(formatMock).toHaveBeenCalledWith(expect.objectContaining({ text }));
          expect(process.stdout.write).toHaveBeenCalledTimes(1);
          expect(process.stdout.write).toHaveBeenCalledWith('MOCK_OUTPUT for stdin');case 8:case "end":return _context4.stop();}}}, _callee4, this);})));


test('will write to files if that is specified', _asyncToGenerator(regeneratorRuntime.mark(function _callee5() {var fileGlob;return regeneratorRuntime.wrap(function _callee5$(_context5) {while (1) {switch (_context5.prev = _context5.next) {case 0:
          fileGlob = 'src/**/1*.js';_context5.next = 3;return (
            formatFiles([fileGlob], { write: true }));case 3:
          expect(fsMock.writeFile).toHaveBeenCalledTimes(4);case 4:case "end":return _context5.stop();}}}, _callee5, this);})));


test('handles stdin errors gracefully', _asyncToGenerator(regeneratorRuntime.mark(function _callee6() {return regeneratorRuntime.wrap(function _callee6$(_context6) {while (1) {switch (_context6.prev = _context6.next) {case 0:
          mockGetStdin.stdin = 'MOCK_SYNTAX_ERROR';_context6.next = 3;return (
            formatFiles([], { stdin: true }));case 3:
          expect(console.error).toHaveBeenCalledTimes(1);case 4:case "end":return _context6.stop();}}}, _callee6, this);})));


test('handles file errors gracefully', _asyncToGenerator(regeneratorRuntime.mark(function _callee7() {var globs, successOutput, failureOutput;return regeneratorRuntime.wrap(function _callee7$(_context7) {while (1) {switch (_context7.prev = _context7.next) {case 0:
          globs = ['files-with-syntax-errors/*.js', 'src/**/1*.js'];_context7.next = 3;return (
            formatFiles(globs, { write: true }));case 3:
          expect(fsMock.writeFile).toHaveBeenCalledTimes(4);
          expect(console.error).toHaveBeenCalledTimes(4);
          successOutput = expect.stringMatching(/success.*4.*files/);
          failureOutput = expect.stringMatching(/failure.*2.*files/);
          expect(console.error).toHaveBeenCalledWith(successOutput);
          expect(console.error).toHaveBeenCalledWith(failureOutput);case 9:case "end":return _context7.stop();}}}, _callee7, this);})));


test('does not print success if there were no successful files', _asyncToGenerator(regeneratorRuntime.mark(function _callee8() {var successOutput;return regeneratorRuntime.wrap(function _callee8$(_context8) {while (1) {switch (_context8.prev = _context8.next) {case 0:_context8.next = 2;return (
            formatFiles(['no-match/*.js']));case 2:
          successOutput = expect.stringMatching(/unhandled error/);
          expect(console.error).not.toHaveBeenCalledWith(successOutput);case 4:case "end":return _context8.stop();}}}, _callee8, this);})));


test('fails gracefully if something odd happens', _asyncToGenerator(regeneratorRuntime.mark(function _callee9() {var label, notice, errorStack;return regeneratorRuntime.wrap(function _callee9$(_context9) {while (1) {switch (_context9.prev = _context9.next) {case 0:_context9.next = 2;return (
            formatFiles(['throw-error/*.js']));case 2:
          expect(console.error).toHaveBeenCalledTimes(1);
          label = expect.stringMatching(/prettier-standard/);
          notice = expect.stringMatching(/unhandled error/);
          errorStack = expect.stringMatching(/something weird happened/);
          expect(console.error).toHaveBeenCalledWith(label, notice, errorStack);case 7:case "end":return _context9.stop();}}}, _callee9, this);})));


test('logs errors to the console if something goes wrong', _asyncToGenerator(regeneratorRuntime.mark(function _callee10() {var globs, successOutput, failureOutput, errorPrefix, cliError, errorOutput;return regeneratorRuntime.wrap(function _callee10$(_context10) {while (1) {switch (_context10.prev = _context10.next) {case 0:
          globs = ['eslint-config-error/*.js', 'src/**/2*.js'];_context10.next = 3;return (
            formatFiles(globs, { write: true }));case 3:
          expect(fsMock.writeFile).toHaveBeenCalledTimes(4);
          expect(console.error).toHaveBeenCalledTimes(4);
          successOutput = expect.stringMatching(/success.*4.*files/);
          failureOutput = expect.stringMatching(/failure.*2.*files/);
          expect(console.error).toHaveBeenCalledWith(successOutput);
          expect(console.error).toHaveBeenCalledWith(failureOutput);
          errorPrefix = expect.stringMatching(/prettier-standard.*ERROR/);
          cliError = expect.stringContaining('eslint-config-error');
          errorOutput = expect.stringContaining('Some weird eslint config error');
          expect(console.error).toHaveBeenCalledTimes(4);
          expect(console.error).toHaveBeenCalledWith(errorPrefix, cliError, errorOutput);case 14:case "end":return _context10.stop();}}}, _callee10, this);})));


test('forwards logLevel onto prettier-eslint', _asyncToGenerator(regeneratorRuntime.mark(function _callee11() {var options;return regeneratorRuntime.wrap(function _callee11$(_context11) {while (1) {switch (_context11.prev = _context11.next) {case 0:_context11.next = 2;return (
            formatFiles(['src/**/1*.js'], { logLevel: 'debug' }));case 2:
          options = expect.objectContaining({ logLevel: 'debug' });
          expect(formatMock).toHaveBeenCalledWith(options);case 4:case "end":return _context11.stop();}}}, _callee11, this);})));


test('wont save file if contents did not change', _asyncToGenerator(regeneratorRuntime.mark(function _callee12() {var fileGlob, unchangedOutput;return regeneratorRuntime.wrap(function _callee12$(_context12) {while (1) {switch (_context12.prev = _context12.next) {case 0:
          fileGlob = 'no-change/*.js';_context12.next = 3;return (
            formatFiles([fileGlob], { write: true }));case 3:
          expect(fsMock.readFile).toHaveBeenCalledTimes(3);
          expect(fsMock.writeFile).toHaveBeenCalledTimes(0);
          unchangedOutput = expect.stringMatching(/3.*?files.*?unchanged/);
          expect(console.error).toHaveBeenCalledWith(unchangedOutput);case 7:case "end":return _context12.stop();}}}, _callee12, this);})));


test('allows you to specify an ignore glob', _asyncToGenerator(regeneratorRuntime.mark(function _callee13() {var ignore, fileGlob, globOptions, callback;return regeneratorRuntime.wrap(function _callee13$(_context13) {while (1) {switch (_context13.prev = _context13.next) {case 0:
          ignore = ['src/ignore/thing', 'src/ignore/otherthing'];
          fileGlob = 'src/**/1*.js';_context13.next = 4;return (
            formatFiles([fileGlob], { ignore }));case 4:

          ignore.push('**/node_modules/**');
          globOptions = expect.objectContaining({
            ignore });

          callback = expect.any(Function);
          expect(globMock).toHaveBeenCalledWith(fileGlob, globOptions, callback);case 8:case "end":return _context13.stop();}}}, _callee13, this);})));


test('wont modify a file if it is eslint ignored', _asyncToGenerator(regeneratorRuntime.mark(function _callee14() {var ignoredOutput;return regeneratorRuntime.wrap(function _callee14$(_context14) {while (1) {switch (_context14.prev = _context14.next) {case 0:_context14.next = 2;return (
            formatFiles(['src/**/ignored*.js'], { write: true }));case 2:
          expect(fsMock.readFile).toHaveBeenCalledTimes(1);
          expect(fsMock.writeFile).toHaveBeenCalledTimes(1);
          expect(fsMock.readFile).toHaveBeenCalledWith(
          expect.stringMatching(/applied/),
          'utf8',
          expect.any(Function));

          expect(fsMock.writeFile).toHaveBeenCalledWith(
          expect.stringMatching(/applied/),
          expect.stringMatching(/MOCK_OUTPUT.*?applied/),
          expect.any(Function));

          ignoredOutput = expect.stringMatching(/success.*1.*file/);
          expect(console.error).toHaveBeenCalledWith(ignoredOutput);case 8:case "end":return _context14.stop();}}}, _callee14, this);})));


test('will modify a file if it is eslint ignored with noIgnore', _asyncToGenerator(regeneratorRuntime.mark(function _callee15() {var ignoredOutput;return regeneratorRuntime.wrap(function _callee15$(_context15) {while (1) {switch (_context15.prev = _context15.next) {case 0:_context15.next = 2;return (
            formatFiles(['src/**/ignored*.js'], {
              write: true,
              eslintIgnore: false }));case 2:

          expect(fsMock.readFile).toHaveBeenCalledTimes(4);
          expect(fsMock.writeFile).toHaveBeenCalledTimes(4);
          ignoredOutput = expect.stringMatching(/success.*4.*files/);
          expect(console.error).toHaveBeenCalledWith(ignoredOutput);case 6:case "end":return _context15.stop();}}}, _callee15, this);})));


test('will not blow up if an .eslintignore cannot be found', _asyncToGenerator(regeneratorRuntime.mark(function _callee16() {var originalSync;return regeneratorRuntime.wrap(function _callee16$(_context16) {while (1) {switch (_context16.prev = _context16.next) {case 0:
          originalSync = findUpMock.sync;
          findUpMock.sync = function () {return '';};_context16.prev = 2;_context16.next = 5;return (

            formatFiles(['src/**/no-eslint-ignore/*.js'], {
              write: true }));case 5:_context16.next = 10;break;case 7:_context16.prev = 7;_context16.t0 = _context16["catch"](2);throw _context16.t0;case 10:_context16.prev = 10;




          findUpMock.sync = originalSync;return _context16.finish(10);case 13:case "end":return _context16.stop();}}}, _callee16, this, [[2, 7, 10, 13]]);})));