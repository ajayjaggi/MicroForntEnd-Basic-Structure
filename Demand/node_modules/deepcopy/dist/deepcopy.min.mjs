/*!
 * @license deepcopy.js Copyright(c) 2013 sasa+1
 * https://github.com/sasaplus1/deepcopy.js
 * Released under the MIT license.
 *
 * type-detect
 * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>
 * MIT Licensed
 */
var commonjsGlobal="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function createCommonjsModule(e,t){return e(t={exports:{}},t.exports),t.exports}var typeDetect=createCommonjsModule(function(e,t){var o,r,n,a,p,i,y,f,c,l,u,s,b,d,g,w,m,S,A,T;e.exports=(o="function"==typeof Promise,r="object"==typeof self?self:commonjsGlobal,n="undefined"!=typeof Symbol,a="undefined"!=typeof Map,p="undefined"!=typeof Set,i="undefined"!=typeof WeakMap,y="undefined"!=typeof WeakSet,f="undefined"!=typeof DataView,c=n&&void 0!==Symbol.iterator,l=n&&void 0!==Symbol.toStringTag,u=p&&"function"==typeof Set.prototype.entries,s=a&&"function"==typeof Map.prototype.entries,b=u&&Object.getPrototypeOf((new Set).entries()),d=s&&Object.getPrototypeOf((new Map).entries()),g=c&&"function"==typeof Array.prototype[Symbol.iterator],w=g&&Object.getPrototypeOf([][Symbol.iterator]()),m=c&&"function"==typeof String.prototype[Symbol.iterator],S=m&&Object.getPrototypeOf(""[Symbol.iterator]()),A=8,T=-1,function(e){var t=typeof e;if("object"!==t)return t;if(null===e)return"null";if(e===r)return"global";if(Array.isArray(e)&&(!1===l||!(Symbol.toStringTag in e)))return"Array";if("object"==typeof window&&null!==window){if("object"==typeof window.location&&e===window.location)return"Location";if("object"==typeof window.document&&e===window.document)return"Document";if("object"==typeof window.navigator){if("object"==typeof window.navigator.mimeTypes&&e===window.navigator.mimeTypes)return"MimeTypeArray";if("object"==typeof window.navigator.plugins&&e===window.navigator.plugins)return"PluginArray"}if(("function"==typeof window.HTMLElement||"object"==typeof window.HTMLElement)&&e instanceof window.HTMLElement){if("BLOCKQUOTE"===e.tagName)return"HTMLQuoteElement";if("TD"===e.tagName)return"HTMLTableDataCellElement";if("TH"===e.tagName)return"HTMLTableHeaderCellElement"}}var n=l&&e[Symbol.toStringTag];if("string"==typeof n)return n;var c=Object.getPrototypeOf(e);return c===RegExp.prototype?"RegExp":c===Date.prototype?"Date":o&&c===Promise.prototype?"Promise":p&&c===Set.prototype?"Set":a&&c===Map.prototype?"Map":y&&c===WeakSet.prototype?"WeakSet":i&&c===WeakMap.prototype?"WeakMap":f&&c===DataView.prototype?"DataView":a&&c===d?"Map Iterator":p&&c===b?"Set Iterator":g&&c===w?"Array Iterator":m&&c===S?"String Iterator":null===c?"Object":Object.prototype.toString.call(e).slice(A,T)})});const isBufferExists="undefined"!=typeof Buffer,isBufferFromExists=isBufferExists&&void 0!==Buffer.from,isBuffer=isBufferExists?function(e){return Buffer.isBuffer(e)}:function(){return!1},copy=isBufferFromExists?function(e){return Buffer.from(e)}:isBufferExists?function(e){return new Buffer(e)}:function(e){return e};function detectType(e){return isBuffer(e)?"Buffer":typeDetect(e)}const collectionTypeSet=new Set(["Arguments","Array","Map","Object","Set"]);function get(e,t,o=null){switch(o||detectType(e)){case"Arguments":case"Array":case"Object":return e[t];case"Map":return e.get(t);case"Set":return t}}function isCollection(e){return collectionTypeSet.has(e)}function set(e,t,o,r=null){switch(r||detectType(e)){case"Arguments":case"Array":case"Object":e[t]=o;break;case"Map":e.set(t,o);break;case"Set":e.add(o)}return e}const freeGlobalThis="undefined"!=typeof globalThis&&null!==globalThis&&globalThis.Object===Object&&globalThis,freeGlobal="undefined"!=typeof global&&null!==global&&global.Object===Object&&global,freeSelf="undefined"!=typeof self&&null!==self&&self.Object===Object&&self,globalObject=freeGlobalThis||freeGlobal||freeSelf||Function("return this")();function copyArrayBuffer(e){return e.slice(0)}function copyBoolean(e){return new Boolean(e.valueOf())}function copyDataView(e){return new DataView(e.buffer)}function copyBuffer(e){return copy(e)}function copyDate(e){return new Date(e.getTime())}function copyNumber(e){return new Number(e)}function copyRegExp(e){return new RegExp(e.source||"(?:)",e.flags)}function copyString(e){return new String(e)}function copyTypedArray(e,t){return globalObject[t].from(e)}function shallowCopy(e){return e}function getEmptyArray(){return[]}function getEmptyMap(){return new Map}function getEmptyObject(){return{}}function getEmptySet(){return new Set}var copyMap=new Map([["ArrayBuffer",copyArrayBuffer],["Boolean",copyBoolean],["Buffer",copyBuffer],["DataView",copyDataView],["Date",copyDate],["Number",copyNumber],["RegExp",copyRegExp],["String",copyString],["Float32Array",copyTypedArray],["Float64Array",copyTypedArray],["Int16Array",copyTypedArray],["Int32Array",copyTypedArray],["Int8Array",copyTypedArray],["Uint16Array",copyTypedArray],["Uint32Array",copyTypedArray],["Uint8Array",copyTypedArray],["Uint8ClampedArray",copyTypedArray],["Array Iterator",shallowCopy],["Map Iterator",shallowCopy],["Promise",shallowCopy],["Set Iterator",shallowCopy],["String Iterator",shallowCopy],["function",shallowCopy],["global",shallowCopy],["WeakMap",shallowCopy],["WeakSet",shallowCopy],["boolean",shallowCopy],["null",shallowCopy],["number",shallowCopy],["string",shallowCopy],["symbol",shallowCopy],["undefined",shallowCopy],["Arguments",getEmptyArray],["Array",getEmptyArray],["Map",getEmptyMap],["Object",getEmptyObject],["Set",getEmptySet]]);function noop(){}function copy$1(e,t=null,o=noop){2===arguments.length&&"function"==typeof t&&(o=t,t=null);const r=t||detectType(e),n=copyMap.get(r);if("Object"===r){const t=o(e,r);if(void 0!==t)return t}return n?n(e,r):e}function deepcopy(e,t={}){"function"==typeof t&&(t={customizer:t});const{customizer:o}=t,r=detectType(e);if(!isCollection(r))return recursiveCopy(e,null,null,null,o);const n=copy$1(e,r,o);return recursiveCopy(e,n,new WeakMap([[e,n]]),new WeakSet([e]),o)}function recursiveCopy(e,t,o,r,n){const a=detectType(e),p=copy$1(e,a);if(!isCollection(a))return p;let i;switch(a){case"Arguments":case"Array":i=Object.keys(e);break;case"Object":(i=Object.keys(e)).push(...Object.getOwnPropertySymbols(e));break;case"Map":case"Set":i=e.keys()}for(let p of i){const i=get(e,p,a);if(r.has(i))set(t,p,o.get(i),a);else{const e=detectType(i),y=copy$1(i,e);isCollection(e)&&(o.set(i,y),r.add(i)),set(t,p,recursiveCopy(i,y,o,r,n),a)}}return t}export default deepcopy;
